syntax = "proto2";

import "opts.proto";
import "fown.proto";

enum IbverbsType {
	UNKNOWN_IBVERBS  = 0;
	RXE              = 1;
}

enum IbverbsObjectType {
	INVALID		= 0;
	PD		= 1;
	COMP_CHANNEL	= 2;
	CQ		= 3;
	QP		= 4;
	SRQ		= 5;
	AH		= 6;
	MR		= 7;
	MW		= 8;
	FLOW		= 9;
	XRCD		= 10;
	RWQ_IND_TBL	= 11;
	WQ		= 12;
	FLOW_ACTION	= 13;
	DM		= 14;
	COUNTERS	= 15;
};

message ibverbs_pd {
};

message ibverbs_mr {
	required uint64	address		= 2;
	required uint64	length		= 3;
	required uint32	access		= 4;
	required uint32	pd_handle	= 5;
	required uint32	lkey		= 6;
	required uint32	rkey		= 7;
};

message ibverbs_cq {
	required uint32 cqe		= 1;
	required uint32 comp_channel	= 2;
	required uint32 comp_vector	= 3;
	required uint64 vm_start	= 4;
	required uint64 vm_size		= 5;
};

message ibverbs_qp {
	required uint64 rq_start	= 1;
	required uint64 rq_size		= 2;
	required uint64 sq_start	= 3;
	required uint64 sq_size		= 4;
	required uint32 pd_handle	= 5;
	required uint32 scq_handle	= 6;
	required uint32 rcq_handle	= 7;
	required uint32 srq_handle	= 8;
	required uint32 qp_type		= 9;
	required uint32 sq_sig_all	= 10;
	required uint32 max_send_wr	= 11;
	required uint32 max_recv_wr	= 12;
	required uint32 max_send_sge	= 13;
	required uint32 max_recv_sge	= 14;
	required uint32 max_inline_data	= 15;
};

message ibverbs_object {
	required IbverbsObjectType	type	= 1;
	required uint32			handle	= 2;
	optional ibverbs_pd		pd	= 3;
	optional ibverbs_mr		mr	= 4;
	optional ibverbs_cq		cq	= 5;
	optional ibverbs_qp		qp	= 6;
};

message ibverbs_entry {
	required uint32 	id 	= 1;
	required uint32		flags	= 2 [(criu).hex = true];
	required fown_entry	fown	= 3;
	repeated ibverbs_object	objs	= 4;
};

message ibevent_entry {
	required uint32 	id 	= 1;
	required uint32		flags	= 2 [(criu).hex = true];
	required fown_entry	fown	= 3;
};
